<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seguimiento de Transporte Inteligente</title>
    
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            background: #000; 
            height: 100vh; 
            width: 100vw; 
            overflow: hidden; 
        }
        #map { 
            position: absolute; 
            top: 0; 
            left: 0; 
            width: 100%; 
            height: 100%; 
            z-index: 1; 
        }
        
        /* Controles mejorados */
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 15px;
            border-radius: 12px;
            z-index: 1000;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            min-width: 220px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .speed-container {
            margin-bottom: 15px;
            text-align: center;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }
        
        .speed-label {
            font-size: 11px;
            opacity: 0.7;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }
        
        .speed-value {
            font-size: 28px;
            font-weight: 800;
            color: #34C759;
            margin-bottom: 4px;
        }
        
        .direction-indicator {
            font-size: 11px;
            opacity: 0.7;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .transport-buttons {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }
        
        .transport-btn {
            padding: 10px 16px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            flex: 1;
            transition: all 0.3s ease;
        }
        
        .transport-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .transport-btn.active {
            background: linear-gradient(135deg, #007AFF, #0056CC);
            box-shadow: 0 4px 12px rgba(0, 122, 255, 0.3);
        }
        
        .line-selector {
            display: none;
            margin-top: 15px;
            animation: fadeIn 0.3s ease;
        }
        
        .line-buttons {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        
        .line-btn {
            padding: 10px 8px;
            border: none;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.3s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .line-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .line-btn.active {
            background: linear-gradient(135deg, #34C759, #28A745);
            box-shadow: 0 4px 12px rgba(52, 199, 89, 0.3);
        }
        
        .auto-detect {
            margin-top: 10px;
            padding: 10px;
            border: 1px dashed rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 13px;
            opacity: 0.9;
        }
        
        .auto-detect:hover {
            background: rgba(255, 255, 255, 0.05);
            border-color: #007AFF;
        }
        
        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.95);
            color: white;
            padding: 20px;
            border-radius: 12px;
            z-index: 1000;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.25);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }
        
        .station-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 15px;
        }
        
        .station-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid transparent;
            transition: all 0.3s ease;
        }
        
        .station-item.current {
            border-left-color: #007AFF;
            background: rgba(0, 122, 255, 0.1);
        }
        
        .station-item.next {
            border-left-color: #34C759;
            background: rgba(52, 199, 89, 0.1);
        }
        
        .station-label {
            font-size: 11px;
            opacity: 0.7;
            margin-bottom: 6px;
            letter-spacing: 0.5px;
        }
        
        .station-name {
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        
        .station-distance {
            font-size: 13px;
            color: #34C759;
            font-weight: 500;
        }
        
        .line-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            opacity: 0.7;
            padding-top: 10px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        @media (max-width: 768px) {
            .controls { 
                left: 10px; 
                top: 10px; 
                right: 10px;
                min-width: auto;
            }
            .info-panel { 
                bottom: 10px; 
                left: 10px; 
                right: 10px; 
            }
            .station-info { 
                grid-template-columns: 1fr; 
                gap: 10px; 
            }
            .transport-buttons {
                flex-direction: column;
            }
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .user-track {
            stroke: #007AFF;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
            fill: none;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { stroke-opacity: 0.8; }
            50% { stroke-opacity: 0.4; }
            100% { stroke-opacity: 0.8; }
        }
        
        .station-marker {
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            transition: all 0.3s ease;
        }
        
        .station-marker.current {
            border-color: #007AFF;
            transform: scale(1.3);
            box-shadow: 0 6px 20px rgba(0, 122, 255, 0.4);
        }
        
        .station-marker.next {
            border-color: #34C759;
            transform: scale(1.2);
            box-shadow: 0 6px 20px rgba(52, 199, 89, 0.4);
            animation: pulse-green 1.5s infinite;
        }
        
        @keyframes pulse-green {
            0% { box-shadow: 0 6px 20px rgba(52, 199, 89, 0.4); }
            50% { box-shadow: 0 6px 30px rgba(52, 199, 89, 0.6); }
            100% { box-shadow: 0 6px 20px rgba(52, 199, 89, 0.4); }
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="controls">
        <div class="speed-container">
            <div class="speed-label">VELOCIDAD ACTUAL</div>
            <div class="speed-value" id="speedValue">0.0 km/h</div>
            <div class="direction-indicator">
                <span id="directionArrow">‚Üí</span>
                <span id="directionText">Detenido</span>
            </div>
        </div>
        
        <div class="transport-buttons">
            <button class="transport-btn active" onclick="selectTransport('train')">üöÜ Trenes</button>
            <button class="transport-btn" onclick="selectTransport('subte')">üöá Subtes</button>
        </div>
        
        <div class="line-selector" id="lineSelector">
            <div class="line-buttons" id="lineButtons"></div>
            <div class="auto-detect" onclick="autoDetectLine()">
                üîç Detectar l√≠nea autom√°ticamente
            </div>
        </div>
    </div>
    
    <div class="info-panel">
        <div class="station-info">
            <div class="station-item current">
                <div class="station-label">ESTACI√ìN ACTUAL</div>
                <div class="station-name" id="currentStation">-</div>
                <div class="station-distance" id="currentDistance">-</div>
            </div>
            <div class="station-item next">
                <div class="station-label">PR√ìXIMA ESTACI√ìN</div>
                <div class="station-name" id="nextStation">-</div>
                <div class="station-distance" id="nextDistance">-</div>
            </div>
        </div>
        <div class="line-info">
            <div>L√≠nea detectada: <span id="detectedLine">-</span></div>
            <div>Modo: <span id="detectionMode">Manual</span></div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // ============================================
        // BASE DE DATOS CON COORDENADAS EXACTAS
        // ============================================
        // (Mantener las mismas estaciones del c√≥digo original)
        const stations = {
            // ... (mantener todo el objeto stations igual)
        };
        
        // L√≠neas disponibles
        const transportLines = {
            train: [
                {id: 'sarmiento', name: 'Sarmiento', color: '#FF3B30'},
                {id: 'mitre_tigre', name: 'Mitre (Tigre)', color: '#007AFF'},
                {id: 'roca', name: 'Roca', color: '#FF9500'},
                {id: 'sanmartin', name: 'San Mart√≠n', color: '#4CD964'},
                {id: 'urquiza', name: 'Urquiza', color: '#FFCC00'},
                {id: 'belgranonorte', name: 'Belgrano Norte', color: '#5856D6'}
            ],
            subte: [
                {id: 'linea_a', name: 'L√≠nea A', color: '#0072BC'},
                {id: 'linea_b', name: 'L√≠nea B', color: '#D9006C'},
                {id: 'linea_c', name: 'L√≠nea C', color: '#00A1E4'},
                {id: 'linea_d', name: 'L√≠nea D', color: '#008E5B'},
                {id: 'linea_h', name: 'L√≠nea H', color: '#FFD700'}
            ]
        };
        
        // ============================================
        // SISTEMA PRINCIPAL MEJORADO
        // ============================================
        
        // Inicializar mapa
        const map = L.map('map');
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap'
        }).addTo(map);
        
        // Variables mejoradas
        let userMarker = null;
        let userTrack = [];
        let trackPolyline = null;
        let stationMarkers = new Map();
        let watchId = null;
        let lastPosition = null;
        let currentSpeed = 0;
        let currentBearing = 0;
        let currentLine = null;
        let currentTransport = 'train';
        let isAutoDetect = false;
        let userHistory = [];
        let lastStationPassed = null;
        
        // Configuraci√≥n
        const CONFIG = {
            AUTO_DETECT_THRESHOLD: 50, // metros para detecci√≥n autom√°tica
            HISTORY_SIZE: 10,
            STATION_PASS_THRESHOLD: 25 // metros para considerar que pas√≥ por una estaci√≥n
        };
        
        // Iniciar GPS mejorado
        function initGPS() {
            if (!navigator.geolocation) {
                alert('GPS no disponible');
                return;
            }
            
            // Ubicaci√≥n inicial por IP
            map.setView([-34.6037, -58.3816], 13);
            
            // Cargar l√≠neas de tren por defecto
            loadTransportLines('train');
            
            // Activar GPS preciso
            navigator.geolocation.getCurrentPosition(position => {
                updatePosition(position);
                map.setView([position.coords.latitude, position.coords.longitude], 15);
            }, null, {
                enableHighAccuracy: true,
                maximumAge: 0,
                timeout: 10000
            });
            
            // Seguimiento continuo mejorado
            watchId = navigator.geolocation.watchPosition(
                position => {
                    updatePosition(position);
                    updateMovementStats(position);
                    
                    // Detectar l√≠nea autom√°ticamente si est√° activado
                    if (isAutoDetect) {
                        autoDetectCurrentLine(
                            position.coords.latitude,
                            position.coords.longitude,
                            currentSpeed,
                            currentBearing
                        );
                    }
                    
                    // Actualizar estaciones cercanas
                    if (currentLine) {
                        updateStationProximity(
                            position.coords.latitude,
                            position.coords.longitude
                        );
                    }
                },
                error => {
                    console.error('GPS Error:', error);
                    document.getElementById('speedValue').textContent = 'GPS Error';
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 1000,
                    timeout: 5000
                }
            );
        }
        
        // Actualizar posici√≥n con seguimiento de ruta
        function updatePosition(position) {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            
            // Actualizar marcador de usuario
            if (userMarker) {
                userMarker.setLatLng([lat, lng]);
            } else {
                userMarker = L.marker([lat, lng], {
                    icon: L.divIcon({
                        className: 'user-marker',
                        html: '<div style="background:#007AFF;width:16px;height:16px;border-radius:50%;border:3px solid white;box-shadow:0 4px 12px rgba(0,122,255,0.6);"></div>',
                        iconSize: [22, 22],
                        iconAnchor: [11, 11]
                    })
                }).addTo(map);
            }
            
            // Agregar a historial de ruta
            userTrack.push([lat, lng]);
            if (userTrack.length > 50) {
                userTrack.shift();
            }
            
            // Actualizar polil√≠nea de ruta
            if (trackPolyline) {
                map.removeLayer(trackPolyline);
            }
            trackPolyline = L.polyline(userTrack, {
                color: '#007AFF',
                weight: 3,
                opacity: 0.7,
                className: 'user-track'
            }).addTo(map);
            
            // Seguir suavemente
            map.panTo([lat, lng], {animate: true, duration: 0.5});
            
            lastPosition = position;
        }
        
        // Actualizar estad√≠sticas de movimiento
        function updateMovementStats(position) {
            if (!lastPosition) return;
            
            const lat1 = lastPosition.coords.latitude;
            const lng1 = lastPosition.coords.longitude;
            const lat2 = position.coords.latitude;
            const lng2 = position.coords.longitude;
            
            // Calcular distancia y velocidad
            const distance = getDistance(lat1, lng1, lat2, lng2);
            const timeDiff = (position.timestamp - lastPosition.timestamp) / 1000;
            
            if (timeDiff > 0) {
                currentSpeed = (distance / timeDiff) * 3.6;
                document.getElementById('speedValue').textContent = 
                    currentSpeed.toFixed(1) + ' km/h';
                
                // Calcular direcci√≥n
                currentBearing = calculateBearing(lat1, lng1, lat2, lng2);
                updateDirectionDisplay(currentBearing, currentSpeed);
            }
            
            // Guardar en historial
            userHistory.push({
                lat: lat2,
                lng: lng2,
                speed: currentSpeed,
                bearing: currentBearing,
                timestamp: position.timestamp
            });
            
            if (userHistory.length > CONFIG.HISTORY_SIZE) {
                userHistory.shift();
            }
        }
        
        // Calcular rumbo/direcci√≥n
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const y = Math.sin(dLon) * Math.cos(lat2 * Math.PI / 180);
            const x = Math.cos(lat1 * Math.PI / 180) * Math.sin(lat2 * Math.PI / 180) -
                     Math.sin(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.cos(dLon);
            return (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;
        }
        
        // Actualizar visualizaci√≥n de direcci√≥n
        function updateDirectionDisplay(bearing, speed) {
            const directionArrow = document.getElementById('directionArrow');
            const directionText = document.getElementById('directionText');
            
            let arrow = '‚Üí';
            let text = 'Norte';
            
            if (speed < 1) {
                arrow = '‚óè';
                text = 'Detenido';
            } else if (bearing >= 337.5 || bearing < 22.5) {
                arrow = '‚Üë';
                text = 'Norte';
            } else if (bearing >= 22.5 && bearing < 67.5) {
                arrow = '‚Üó';
                text = 'Noreste';
            } else if (bearing >= 67.5 && bearing < 112.5) {
                arrow = '‚Üí';
                text = 'Este';
            } else if (bearing >= 112.5 && bearing < 157.5) {
                arrow = '‚Üò';
                text = 'Sureste';
            } else if (bearing >= 157.5 && bearing < 202.5) {
                arrow = '‚Üì';
                text = 'Sur';
            } else if (bearing >= 202.5 && bearing < 247.5) {
                arrow = '‚Üô';
                text = 'Suroeste';
            } else if (bearing >= 247.5 && bearing < 292.5) {
                arrow = '‚Üê';
                text = 'Oeste';
            } else if (bearing >= 292.5 && bearing < 337.5) {
                arrow = '‚Üñ';
                text = 'Noroeste';
            }
            
            directionArrow.textContent = arrow;
            directionText.textContent = text;
        }
        
        // Cargar l√≠neas de transporte
        function loadTransportLines(transport) {
            currentTransport = transport;
            
            // Actualizar botones
            document.querySelectorAll('.transport-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            const lineButtons = document.getElementById('lineButtons');
            lineButtons.innerHTML = '';
            
            transportLines[transport].forEach(line => {
                const button = document.createElement('button');
                button.className = 'line-btn';
                button.textContent = line.name;
                button.style.background = `rgba(${hexToRgb(line.color)}, 0.1)`;
                button.style.border = `1px solid ${line.color}`;
                button.onclick = () => selectLine(line.id, line.name, line.color);
                lineButtons.appendChild(button);
            });
            
            // Mostrar selector
            document.getElementById('lineSelector').style.display = 'block';
            isAutoDetect = false;
            document.getElementById('detectionMode').textContent = 'Manual';
        }
        
        // Seleccionar l√≠nea manualmente
        function selectLine(lineId, lineName, lineColor) {
            currentLine = lineId;
            isAutoDetect = false;
            
            // Actualizar botones
            document.querySelectorAll('.line-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
            
            // Ocultar selector
            document.getElementById('lineSelector').style.display = 'none';
            
            // Cargar estaciones
            loadStations(lineId, lineColor);
            document.getElementById('detectedLine').textContent = lineName;
            document.getElementById('detectionMode').textContent = 'Manual';
            
            // Buscar estaciones cercanas
            if (lastPosition) {
                updateStationProximity(
                    lastPosition.coords.latitude,
                    lastPosition.coords.longitude
                );
            }
        }
        
        // Cargar estaciones con marcadores especiales
        function loadStations(lineId, lineColor) {
            // Limpiar estaciones anteriores
            stationMarkers.forEach(marker => map.removeLayer(marker));
            stationMarkers.clear();
            
            if (stations[lineId]) {
                stations[lineId].forEach((station, index) => {
                    const marker = L.marker([station.lat, station.lng], {
                        icon: L.divIcon({
                            className: 'station-marker',
                            html: `<div style="background:${lineColor};width:12px;height:12px;"></div>`,
                            iconSize: [18, 18],
                            iconAnchor: [9, 9]
                        })
                    })
                    .bindPopup(`<b>${station.name}</b><br>Orden: ${index + 1}`)
                    .addTo(map);
                    
                    stationMarkers.set(station.name, {
                        marker: marker,
                        index: index,
                        data: station
                    });
                });
            }
        }
        
        // Detectar l√≠nea autom√°ticamente
        function autoDetectLine() {
            isAutoDetect = true;
            document.getElementById('lineSelector').style.display = 'none';
            document.getElementById('detectionMode').textContent = 'Autom√°tico';
            
            if (lastPosition) {
                autoDetectCurrentLine(
                    lastPosition.coords.latitude,
                    lastPosition.coords.longitude,
                    currentSpeed,
                    currentBearing
                );
            }
        }
        
        // Detectar la l√≠nea actual basado en posici√≥n y movimiento
        function autoDetectCurrentLine(userLat, userLng, speed, bearing) {
            let bestMatch = null;
            let bestScore = 0;
            
            // Analizar todas las l√≠neas del transporte seleccionado
            transportLines[currentTransport].forEach(line => {
                const lineScore = calculateLineMatchScore(
                    line.id,
                    userLat,
                    userLng,
                    speed,
                    bearing
                );
                
                if (lineScore > bestScore) {
                    bestScore = lineScore;
                    bestMatch = line;
                }
            });
            
            if (bestMatch && bestScore > 0.3) {
                // Solo cambiar si el score es significativo
                if (currentLine !== bestMatch.id) {
                    currentLine = bestMatch.id;
                    loadStations(bestMatch.id, bestMatch.color);
                    document.getElementById('detectedLine').textContent = bestMatch.name;
                    
                    if (lastPosition) {
                        updateStationProximity(
                            lastPosition.coords.latitude,
                            lastPosition.coords.longitude
                        );
                    }
                }
            }
        }
        
        // Calcular puntaje de coincidencia con l√≠nea
        function calculateLineMatchScore(lineId, userLat, userLng, speed, bearing) {
            if (!stations[lineId]) return 0;
            
            const lineStations = stations[lineId];
            let totalScore = 0;
            
            // 1. Puntaje por proximidad a estaciones
            let minDistance = Infinity;
            lineStations.forEach(station => {
                const distance = getDistance(userLat, userLng, station.lat, station.lng);
                if (distance < minDistance) minDistance = distance;
            });
            
            const proximityScore = Math.max(0, 1 - (minDistance / 1000));
            
            // 2. Puntaje por alineaci√≥n con la l√≠nea
            if (speed > 5 && userHistory.length > 2) {
                const alignmentScore = calculateAlignmentScore(lineId);
                totalScore = (proximityScore * 0.6) + (alignmentScore * 0.4);
            } else {
                totalScore = proximityScore;
            }
            
            return totalScore;
        }
        
        // Calcular alineaci√≥n con la l√≠nea
        function calculateAlignmentScore(lineId) {
            const lineStations = stations[lineId];
            if (!lineStations || lineStations.length < 2) return 0;
            
            // Calcular direcci√≥n promedio de la l√≠nea
            let lineBearingSum = 0;
            for (let i = 1; i < lineStations.length; i++) {
                const bearing = calculateBearing(
                    lineStations[i-1].lat, lineStations[i-1].lng,
                    lineStations[i].lat, lineStations[i].lng
                );
                lineBearingSum += bearing;
            }
            const avgLineBearing = lineBearingSum / (lineStations.length - 1);
            
            // Calcular direcci√≥n promedio del usuario
            let userBearingSum = 0;
            for (let i = 1; i < userHistory.length; i++) {
                const bearing = calculateBearing(
                    userHistory[i-1].lat, userHistory[i-1].lng,
                    userHistory[i].lat, userHistory[i].lng
                );
                userBearingSum += bearing;
            }
            const avgUserBearing = userBearingSum / (userHistory.length - 1);
            
            // Calcular diferencia
            const bearingDiff = Math.abs(avgUserBearing - avgLineBearing) % 360;
            const diff = Math.min(bearingDiff, 360 - bearingDiff);
            
            return Math.max(0, 1 - (diff / 180));
        }
        
        // Actualizar proximidad a estaciones
        function updateStationProximity(userLat, userLng) {
            if (!currentLine || !stations[currentLine]) return;
            
            const lineStations = stations[currentLine];
            let currentStation = null;
            let currentDistance = Infinity;
            let currentIndex = -1;
            
            let nextStation = null;
            let nextDistance = Infinity;
            let nextIndex = -1;
            
            // Encontrar estaci√≥n m√°s cercana y siguiente
            lineStations.forEach((station, index) => {
                const distance = getDistance(userLat, userLng, station.lat, station.lng);
                
                if (distance < currentDistance) {
                    // Si ya ten√≠amos una estaci√≥n actual, verificar si la pasamos
                    if (currentStation && distance < CONFIG.STATION_PASS_THRESHOLD) {
                        if (lastStationPassed !== station.name) {
                            // El usuario pas√≥ por una nueva estaci√≥n
                            onStationPassed(station.name);
                        }
                    }
                    
                    currentDistance = distance;
                    currentStation = station;
                    currentIndex = index;
                }
            });
            
            if (!currentStation) return;
            
            // Determinar direcci√≥n del viaje
            const direction = determineTravelDirection(currentIndex);
            
            // Encontrar siguiente estaci√≥n seg√∫n direcci√≥n
            if (direction === 'forward' && currentIndex < lineStations.length - 1) {
                nextIndex = currentIndex + 1;
            } else if (direction === 'backward' && currentIndex > 0) {
                nextIndex = currentIndex - 1;
            }
            
            if (nextIndex >= 0) {
                nextStation = lineStations[nextIndex];
                nextDistance = getDistance(userLat, userLng, nextStation.lat, nextStation.lng);
            }
            
            // Actualizar marcadores de estaciones
            updateStationMarkers(currentStation.name, nextStation ? nextStation.name : null);
            
            // Actualizar panel de informaci√≥n
            updateStationInfo(currentStation, currentDistance, nextStation, nextDistance);
        }
        
        // Determinar direcci√≥n del viaje
        function determineTravelDirection(currentIndex) {
            if (userHistory.length < 3) return 'forward';
            
            // Analizar historial reciente para determinar direcci√≥n
            const recentPoints = userHistory.slice(-5);
            let avgLat = 0, avgLng = 0;
            recentPoints.forEach(point => {
                avgLat += point.lat;
                avgLng += point.lng;
            });
            avgLat /= recentPoints.length;
            avgLng /= recentPoints.length;
            
            // Calcular hacia d√≥nde se est√° moviendo en relaci√≥n con la l√≠nea
            return 'forward'; // Por ahora, siempre forward (se puede mejorar)
        }
        
        // Actualizar marcadores de estaciones
        function updateStationMarkers(currentStationName, nextStationName) {
            stationMarkers.forEach((data, stationName) => {
                const marker = data.marker;
                
                // Resetear todos los marcadores
                marker._icon.classList.remove('current', 'next');
                
                // Aplicar clases seg√∫n corresponda
                if (stationName === currentStationName) {
                    marker._icon.classList.add('current');
                } else if (stationName === nextStationName) {
                    marker._icon.classList.add('next');
                }
            });
        }
        
        // Actualizar informaci√≥n de estaciones
        function updateStationInfo(currentStation, currentDist, nextStation, nextDist) {
            if (!currentStation) return;
            
            // Estaci√≥n actual
            document.getElementById('currentStation').textContent = currentStation.name;
            document.getElementById('currentDistance').textContent = 
                Math.round(currentDist) + ' metros';
            
            // Pr√≥xima estaci√≥n
            if (nextStation) {
                document.getElementById('nextStation').textContent = nextStation.name;
                document.getElementById('nextDistance').textContent = 
                    Math.round(nextDist) + ' metros';
            } else {
                document.getElementById('nextStation').textContent = '-';
                document.getElementById('nextDistance').textContent = '-';
            }
        }
        
        // Evento cuando el usuario pasa por una estaci√≥n
        function onStationPassed(stationName) {
            lastStationPassed = stationName;
            
            // Aqu√≠ puedes agregar notificaciones o acciones adicionales
            console.log(`Pas√≥ por la estaci√≥n: ${stationName}`);
            
            // Actualizar marcador de la estaci√≥n pasada
            const stationData = stationMarkers.get(stationName);
            if (stationData) {
                stationData.marker._icon.classList.remove('current', 'next');
            }
        }
        
        // Funci√≥n de distancia (f√≥rmula de Haversine)
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = 
                Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
                Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        // Convertir hex a rgb
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? 
                `${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}` : 
                '0, 0, 0';
        }
        
        // Iniciar todo
        document.addEventListener('DOMContentLoaded', function() {
            initGPS();
        });
        
        // Actualizar tama√±o del mapa
        window.addEventListener('resize', function() {
            map.invalidateSize();
        });
    </script>
</body>
</html> 